<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="icon" href="data:;base64,=">
<!-- <script src="https://cdn.jsdelivr.net/npm/exif-js"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/exif-js/2.3.0/exif.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
</head>
<body>

<label for="root_input">Target folder</label>
<input id="root_input" type="text" placeholder="photos/ or music/ or ..."></input><br/>
<label for="auto_input" checked>Auto target folder</label>
<input id="auto_input" type="checkbox" checked></input><br/>
<label for="check_duplicates" checked>Skip duplicates upload </label>
<input id="check_duplicates" type="checkbox" checked></input><br/><br/>
<input id="file_input" type="file" multiple="multiple"></input><br/><br/>

<span id=status></span>

<script>
/* global Blob */
/* global EXIF */

const lambda_url = "https://5nn8oaty7b.execute-api.eu-west-3.amazonaws.com/default";
// const lambda_url = "/default";
const chunk_size = 1024*1024;

const photo_exts = [ "jpeg", "jpg", "png" ];
const audio_exts = [ "mp3", "mp4", "m4a" ];

const prms = get_params();

window.onload = function () {
    document.getElementById("file_input").addEventListener("change", evt => upload(evt));
};

async function upload(evt) {
    var root = document.getElementById("root_input").value || "";
    var auto = document.getElementById("auto_input").checked;
    var files = Array.from(document.getElementById("file_input").files);
    var check_duplicates = document.getElementById("check_duplicates").checked;;
    var status_elnt = document.getElementById("status");

    if (root && !root.endsWith("/"))
         root += "/";

    status_elnt.innerHTML = ""
    
    // smaller files first
    files.sort((a, b) => a.size - b.size);
    
    if (check_duplicates) 
        files = await remove_duplicates(files, status_elnt);
    status_elnt.innerHTML += `<p>Uploading ${files.length} file(s) ...</p>`;

    for (const file of files) {
        try {
            var { name, size, type, lastModifiedDate } = file;
            status_elnt.innerHTML += `<p>Uploading ${name} (${Math.round(size/1024)}kB)</p>`;

            var key, infos = { name, size, type, lastModifiedDate };

            var ext = name.split('.').pop();
            var mime = type ? type.split('/')[0] : "";
            var is_photo = mime == "image" || photo_exts.indexOf(ext) != -1;
            var is_audio = mime == "audio" || audio_exts.indexOf(ext) != -1;

            // retriving photos metadata
            var meta = null;
            if (auto && is_photo) {
                try {
                    meta = await get_exif_infos(file);
                    infos = { ...infos, ...meta };
                    status_elnt.innerHTML += `<p>Exif metadata ${JSON.stringify(meta)}</p>`;
                } catch (e) {
                    status_elnt.innerHTML += `<p>Exif error ${e}</p>`;
                }
            }
            
            // using metadata
            var used_root = root || ( is_photo ? "photos/" : ( is_audio ? "music/" : "uploads/")) ;
            if (used_root.endsWith('/'))
                used_root = used_root.slice(0, -1);
            if (meta && meta.DateTime) {
                var iso_date = meta.DateTime.replace(/:/g, "-");
                key = used_root + "/" +  iso_date.substr(0,4) + "/" + iso_date.substr(0,7) + "/" + iso_date + " " + name;
            } else {
                key = used_root + "/" + name;
            }

            var res = await send_file(key, file, infos);
            try { res = JSON.parse(res); } catch (e) {}

            status_elnt.innerHTML += `<p>&#9989;  <a href="${res.url}">${key}</a></p>`;
        } catch (e) {
            status_elnt.innerHTML += `<p>&#10060; <b style="color: brown;">${e.message||e}<pre><br/><br/>${e.stack||""}</pre></b></p><br/>`;
        }
    }
}

async function send_file_multipart(name, file, meta) {
    var status_elnt = document.getElementById("status");
    status_elnt.innerHTML += `<p id="progress"></p>`;

    // upload parts
    var n = Math.ceil(file.size/chunk_size);
    for (var i=0; i<n; i++) {
        status_elnt.lastElementChild.innerHTML = `Uploading part ${i+1}/${n}...`;
        
        var beg = i * chunk_size;
        var end = Math.min((i+1) * chunk_size, file.size);
        var blob = file.slice(beg, end);
        var http_headers = { "multipart": i+"/"+n };
        await send_file(name+"."+i, blob, meta, http_headers);
    }

    // concatenate parts
    status_elnt.lastElementChild.innerHTML = `Concatenateing parts...`;
    blob = new Blob(["Done"]);
    http_headers = { "multipart": n+"/"+n };
    var res = await send_file(name, blob, meta, http_headers);
    
    status_elnt.lastElementChild.remove();
    return res;
}

async function send_file(name, file, meta, http_headers) {
    if (file.size>chunk_size) 
        return await send_file_multipart(name, file, meta);

    meta.name = name;
    
    // get rid of undefined values
    var tmp = {}; for (var k in meta) if (meta[k] !== undefined) tmp[k] = meta[k]; meta = tmp; 
        
    // var urlenc = await file_to_urlencoded(file);
    var bintxt = await file_to_binary_string(file);
    // var base64 = btoa(bintxt);
    
    return new Promise((resolve, reject) => {
        var xhr = new XMLHttpRequest;
        var query = new URLSearchParams({ ...prms, ...meta }).toString();
        xhr.open("POST", lambda_url + "/upload?" + query);
        // xhr.setRequestHeader('Content-Type', 'application/octet-stream'); 

        if (http_headers)
            for (var k in http_headers)
                xhr.setRequestHeader(k, http_headers[k]);

        xhr.onload = function (e) {
            var response = xhr.response || xhr.responseText;
            resolve(response);
        };
        
        xhr.onreadystatechange = function handler() {
            if(this.readyState == this.DONE) {
                if (this.status != 200)
                    reject(`Http error ${this.status}.  ${this.responseText}`);
            }
        };
        
        xhr.error = function(e) {
            reject(`Upload error ${e}.`);
        };

        xhr.send(bintxt);
    });
}

async function file_to_binary_string(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.addEventListener("load", function () {
            resolve(reader.result);
        }, false);
        reader.readAsBinaryString(file);
    });
}

async function file_to_urlencoded(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.addEventListener("load", function () {
            resolve(reader.result);
        }, false);
        reader.readAsDataURL(file);
    });
}

async function get_exif_infos(img) {
    return new Promise((resolve, reject) => {
        EXIF.getData(img, function() {
            var all_tags = EXIF.getAllTags(this);

            // extract subset 
            var { Make, Model, DateTime, Orientation, FocalLengthIn35mmFilm, FNumber, ExposureTime, ...other } = all_tags;
            var meta = { Make, Model, DateTime, Orientation, FocalLengthIn35mmFilm, FNumber, ExposureTime };
            
            // try to get timestamp
            var timestamp = null;
            if (DateTime) {
                try {
                    timestamp = new Date(meta.DateTime);
                } catch (e) {}
                
                if (!isValidDate(timestamp)) 
                try {
                    var tok = DateTime.split(/[-: ]+/).map(x => x*1);
                    timestamp = new Date(tok[0], tok[1]-1, tok[2], tok[3], tok[4], tok[5]);  // the month is 0-indexed
                    if (isValidDate(timestamp)) 
                        // meta.DateTime = DateTime.substr(0,10).replaceAll(":", "-")+DateTime.substr(10);
                        meta.DateTime = DateTime.replaceAll(":", "-"); // do not preserve ':' in time part as it is an illegal character in a file path
                } catch (e) {}
                
            }
            if (!isValidDate(timestamp)) 
                reject(`Couldn't extract timestamp from EXIF data. ${DateTime}`);
            else 
                resolve(meta);
        });
    });
}

function isValidDate(d) {
  return d instanceof Date && !isNaN(d);
}

async function remove_duplicates(files, status_elnt) {
    status_elnt.innerHTML += `<p>Getting existing files...</p>`;
    var t0 = new Date();
    var existing_files = await get_existing_files();
    var t1 = new Date();
    status_elnt.innerHTML += `<p>(took ${t1-t0}ms)</p>`;

    status_elnt.innerHTML += `<p>Checking files already uploaded...</p>`;
    var t0 = new Date();
    var skip_files = new Set((await async_filter(files, f => skip_file_check(f, existing_files))).map(f => f.name));
    var keep_files = files.filter(f => !skip_files.has(f.name));
    var t1 = new Date();
    status_elnt.innerHTML += `<p>(took ${t1-t0}ms)</p>`;

    if (skip_files.size>0)
        status_elnt.innerHTML += `<p>&#x26A0;&#xFE0F; Skipping ${skip_files.size} files already uploaded.</p>`;
    return keep_files;
} 

async function async_filter(my_array, my_callback) {
  const fail = Symbol()
  var promises = my_array.map(async item => (await my_callback(item)) ? item : fail);
  var selected = (await Promise.all(promises)).filter(i => i!==fail);
  return selected;
}

async function skip_file_check(file, existing_files) {
    var same_size = existing_files.by_size[file.size];
    if (!same_size)
        // no file with that size => do not skip
        return false;
    
    var hash = await calculate_hash(file);
    var same_hash = existing_files.by_hash[hash];
    if (!same_hash)
         // no file with that hash  => do not skip
        return false;
    
    // found file with that size and hash => already upladed => skip file
    return true;
}

async function calculate_hash(file) {
    var data0 = await file.arrayBuffer();
    var data1 = CryptoJS.lib.WordArray.create(data0);
    var hash1 = CryptoJS.MD5(data1).toString();
    return hash1;
   
}

async function get_existing_files(args) {
    var files = await list_files();
    var by_size = fs_by_key(files, "Size");
    var by_hash = fs_by_key(files, "ETag");
    return { files, by_size, by_hash };
}

async function list_files(args) {
    var fs = new Promise((resolve, reject) => {
    
        var qs = new URLSearchParams({ ...prms, ...args });
        $.ajax({
            url: "https://aws.kljh.org/fs?"+qs,
            type : "POST"
        })
        .done(data => {
            console.log(data);
            resolve(data);
        })
        .fail(err => {
            console.error(err);
            reject(err);
        });
    });

    return fs;
}

function fs_by_key(fs, key) {
    // key should be Size or ETag
    var by_key = {};
    for (var f of fs.Contents) {
        var k = f[key];
        if (k.replace) // get rid of quotes in AWS Etags
            k = k.replace(/"/g, '');
        if (!by_key[k])
            by_key[k] = [];
        by_key[k].push(f);
    }
    return by_key;
}

function get_params() {
    var cookies = Object.fromEntries(document.cookie.split(';')
        .map(kv => kv.split('=').map(x => x.trim())));
    
    var query = Object.fromEntries(window.location.search.substring(1).split('&')
        .map(x => x.split('='))
        .map(kv => [ decodeURIComponent(kv[0]), decodeURIComponent(kv[1]) ]));

    return { ...cookies, ...query };
}
     
</script>
</body>
</html>
